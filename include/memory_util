#pragma once

#include <Windows.h>  // VirtualAlloc, VirtualFree, VirtualProtect
//
#include <Psapi.h>  // MODULEINFO

#include <_Log_>
#include <cstdint>
#include <stdexcept>
#include <string>
#include <string_format>
#include <vector>

namespace MemoryUtil {

    class Bytes {
        std::vector<uint8_t> _bytes;

    public:
        Bytes() = default;
        Bytes(std::vector<uint8_t> bytes) : _bytes(bytes) {}
        Bytes(const Bytes& other) : _bytes(other._bytes) {}

        std::vector<uint8_t> GetBytes() { return _bytes; }
        size_t               GetByteCount() { return _bytes.size(); }
        size_t               size() { return GetByteCount(); }

        Bytes& AddByte(uint8_t byte) {
            _bytes.push_back(byte);
            return *this;
        }
        Bytes& AddBytes(std::vector<uint8_t> bytes) {
            for (auto byte : bytes) _bytes.push_back(byte);
            return *this;
        }

        Bytes& Add8(uint8_t byte) {
            AddByte(byte);
            return *this;
        }
        Bytes& Add16(uint16_t word) {
            _bytes.push_back((word >> 0) & 0xFF);
            _bytes.push_back((word >> 8) & 0xFF);
            return *this;
        }
        Bytes& Add32(uint32_t dword) {
            _bytes.push_back((dword >> 0) & 0xFF);
            _bytes.push_back((dword >> 8) & 0xFF);
            _bytes.push_back((dword >> 16) & 0xFF);
            _bytes.push_back((dword >> 24) & 0xFF);
            return *this;
        }
        Bytes& Add64(uint64_t qword) {
            _bytes.push_back((qword >> 0) & 0xFF);
            _bytes.push_back((qword >> 8) & 0xFF);
            _bytes.push_back((qword >> 16) & 0xFF);
            _bytes.push_back((qword >> 24) & 0xFF);
            _bytes.push_back((qword >> 32) & 0xFF);
            _bytes.push_back((qword >> 40) & 0xFF);
            _bytes.push_back((qword >> 48) & 0xFF);
            _bytes.push_back((qword >> 56) & 0xFF);
            return *this;
        }

        Bytes& AddWord(uint16_t word) {
            Add16(word);
            return *this;
        }
        Bytes& AddDword(uint32_t dword) {
            Add32(dword);
            return *this;
        }
        Bytes& AddQword(uint64_t qword) {
            Add64(qword);
            return *this;
        }

        Bytes& AddAddress(uintptr_t address) {
            if (sizeof(uintptr_t) == 4) Add32(address);
            else if (sizeof(uintptr_t) == 8) Add64(address);
            else
                throw std::runtime_error(
                    string_format("Bytes: Unsupported address size {}", sizeof(uintptr_t))
                );
            return *this;
        }

        Bytes& Add(uint8_t byte) { return AddByte(byte); }
        Bytes& Add(std::vector<uint8_t> bytes) { return AddBytes(bytes); }
        Bytes& Add(uint16_t word) { return AddWord(word); }
        Bytes& Add(uint32_t dword) { return AddDword(dword); }
        Bytes& Add(uint64_t qword) { return AddQword(qword); }

        std::string ToHexString() const {
            std::string str;
            for (auto byte : _bytes) str += string_format("{:x} ", byte);
            return str;
        }

        std::string ToEncodedString() const {
            std::string str;
            for (auto byte : _bytes) str += string_format("\\x{:x}", byte);
            return str;
        }

        static Bytes FromHexString(const std::string& hexString) {
            std::vector<uint8_t> bytes;
            std::string          hex;
            for (auto c : hexString) {
                if (c == ' ') {
                    if (hex.empty()) continue;
                    bytes.push_back(static_cast<uint8_t>(std::stoi(hex, nullptr, 16)));
                    hex.clear();
                } else {
                    hex += c;
                }
            }
            if (!hex.empty()) bytes.push_back(static_cast<uint8_t>(std::stoi(hex, nullptr, 16)));
            return Bytes{bytes};
        }

        // TODO support escaped strings (e.g. \x00)
        static Bytes FromString(const std::string& str) { return FromHexString(str); }

        operator std::vector<uint8_t>() const { return _bytes; }
    };

    std::string ToEncodedString(const Bytes& bytes) { return bytes.ToEncodedString(); }
    std::string ToHexString(const Bytes& bytes) { return bytes.ToHexString(); }

    // TODO support escaped strings (e.g. \x00)
    Bytes GetBytes(const std::string& hexString) { return Bytes::FromHexString(hexString); }

    std::vector<uint8_t> Read(uintptr_t address, size_t size) {
        std::vector<uint8_t> bytes(size);
        for (size_t i = 0; i < size; i++) bytes[i] = *reinterpret_cast<uint8_t*>(address + i);
        return bytes;
    }

    template <typename T>
    T Read(uintptr_t address) {
        return (T)(address);
    }

    template <typename T>
    T Read(uintptr_t address, uint32_t offset) {
        address = *reinterpret_cast<uintptr_t*>(address + offset);
        return (T)(address);
    }

    template <typename T>
    T Read(uintptr_t address, std::vector<uint32_t> offsets) {
        for (auto offset : offsets) address = *reinterpret_cast<uintptr_t*>(address + offset);
        return (T)(address);
    }

    template <typename T>
    T Read(uintptr_t address, uint32_t offset1, uint32_t offset2) {
        return Read<T>(address, {offset1, offset2});
    }

    template <typename T>
    T Read(uintptr_t address, uint32_t offset1, uint32_t offset2, uint32_t offset3) {
        return Read<T>(address, {offset1, offset2, offset3});
    }

    void Write(uintptr_t address, const std::vector<uint8_t>& bytes) {
        _Log_("Writing {} bytes to address {:x}", bytes.size(), address);
        if (bytes.size() < 128) _Log_(Bytes{bytes}.ToHexString());
        for (size_t i = 0; i < bytes.size(); i++) *(uint8_t*)(address + i) = bytes[i];
    }

    void WriteProtected(uintptr_t address, const std::vector<uint8_t>& bytes) {
        _Log_("Writing {} protected bytes to address {:x}", bytes.size(), address);
        if (bytes.size() < 128) _Log_(Bytes{bytes}.ToHexString());
        DWORD oldProtect;
        VirtualProtect((void*)address, bytes.size(), PAGE_EXECUTE_READWRITE, &oldProtect);
        memcpy((void*)address, bytes.data(), bytes.size());
        VirtualProtect((void*)address, bytes.size(), oldProtect, &oldProtect);
    }

    uintptr_t Allocate(size_t size) {
        _Log_("Allocating {} bytes", size);
        auto addressPtr = VirtualAlloc(0, size, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
        if (addressPtr == nullptr) throw std::runtime_error("Failed to allocate memory");
        auto address = reinterpret_cast<uintptr_t>(addressPtr);
        _Log_("Allocated at address {:x}", address);
        return address;
    }

    void Free(uintptr_t address) {
        _Log_("Freeing memory at address {:x}", address);
        if (VirtualFree((void*)address, 0, MEM_RELEASE))
            _Log_("Freed memory at address {:x}", address);
        else
            throw std::runtime_error(string_format("Failed to free memory at address {:x}", address)
            );
    }

    uintptr_t Find(
        const std::string& moduleName, Bytes pattern, const std::string& mask,
        uintptr_t startOffset = 0
    ) {
        std::string theMask{mask};
        if (theMask.empty()) theMask = std::string(pattern.size(), 'x');
        _Log_(
            "Search: Searching for pattern {} with mask {} in module {}", pattern.ToHexString(),
            theMask, moduleName
        );

        auto module = GetModuleHandleA(moduleName.c_str());
        if (module == nullptr) {
            _Log_("Search: Failed to get module handle for module {}", moduleName);
            return 0;
        }

        MODULEINFO moduleInfo;
        if (!GetModuleInformation(GetCurrentProcess(), module, &moduleInfo, sizeof(moduleInfo))) {
            _Log_("Search: Failed to get module information for module {}", moduleName);
            return 0;
        }

        auto moduleStart = reinterpret_cast<uintptr_t>(moduleInfo.lpBaseOfDll);
        auto moduleEnd   = moduleStart + moduleInfo.SizeOfImage;
        auto searchStart = moduleStart + startOffset;
        _Log_(
            "Search: Module {} starts at 0x{:x} + offset 0x{:x} (0x{:x}) and ends at 0x{:x}",
            moduleName, moduleStart, startOffset, searchStart, moduleEnd
        );

        auto patternBytes = pattern.GetBytes();
        auto patternSize  = pattern.GetByteCount();

        for (uintptr_t i = searchStart; i < moduleEnd - patternSize; i++) {
            bool found = true;
            for (size_t j = 0; j < patternSize; j++) {
                if (theMask[j] == 'x' && patternBytes[j] != *reinterpret_cast<uint8_t*>(i + j)) {
                    found = false;
                    break;
                }
            }
            if (found) {
                _Log_("Search: Found pattern at 0x{:x}", i);
                return i;
            }
        }

        _Log_("Search: Failed to find pattern in module {}", moduleName);
        return 0;
    }

    uintptr_t Find(
        const std::string& moduleName, const std::vector<uint8_t>& patternBytes,
        const std::string& mask, uintptr_t startOffset = 0
    ) {
        return Find(moduleName, Bytes{patternBytes}, mask, startOffset);
    }

    uintptr_t Find(
        const std::string& moduleName, const std::string& pattern, const std::string& mask,
        uintptr_t startOffset = 0
    ) {
        return Find(moduleName, Bytes::FromString(pattern), mask, startOffset);
    }
}